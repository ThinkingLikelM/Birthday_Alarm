/* This the Third Version of the clock, which makes me really excited.For the first time , I did a project which really like a real clock.
   It can show the real time, it can set the alarm and stop it.
   For the last 2 Versions which is in other file. I realized the function of setting and getting the time in DS3231 and set the alarm.
   But there are some problems between and <Wire.h> and <U8g2lib.h>. Once you write the sentence of 'Wire.begin()' in the setup(), the sda would be blocked and the 
   screen would stop and can not show any changes anymore. 
   Problem GitHub Refference:https://github.com/olikraus/u8g2/discussions/2422
   So in the thired version, I use the RTClib.h instead of DS3231.h.
   Hoping add more functions in the future.
   ---2024/11/17 00.10.28
   Version 4:add the birthday picture while the alarm working and change the Ringtones to the "Happy Birthday" --2024/11/17
*/
#include "RTClib.h"

#include "pitches.h"

#include <Arduino.h>
#include <U8g2lib.h>

#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif
#ifdef U8X8_HAVE_HW_I2C
#include <Wire.h>
#endif

// create the instance of RTC  and U8g2
RTC_DS3231 rtc;
//U8G2_SH1106_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
U8G2_SSD1306_128X64_NONAME_1_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
//U8G2_SSD1306_128X64_NONAME_1_SW_I2C u8g2(U8G2_R0, /* clock=*/ SCL, /* data=*/ SDA, /* reset=*/ U8X8_PIN_NONE);
//set pin 12 as the output to control the buzzer
int buzzer = 12;
//set pin13 as the input of button signal
int button = 13;
int buttone_state =1;
//set specific time
int set_Hour = 21;
int set_Minute =51;
//set alarm lock to avoid the buzzer ring again once the button is pressed
int alarm_lock = 0;
// Generally, you should use "unsigned long" for variables that hold time
// The value will quickly become too large for an int to store
unsigned long previousMillis = 0;  // will store last time LED was updated
unsigned long currentMillis = 0;
// constants won't change:

int buzzer_state = 1000;

//const long interval = 1000;  // interval at which to blink (milliseconds)

// constants won't change:
//const long interval = 1000;  // interval at which to blink (milliseconds)

int melody[] = {
  NOTE_C4, NOTE_C4, 
  NOTE_D4, NOTE_C4, NOTE_F4,
  NOTE_E4, NOTE_C4, NOTE_C4, 
  NOTE_D4, NOTE_C4, NOTE_G4,
  NOTE_F4, NOTE_C4, NOTE_C4,
  
  NOTE_C5, NOTE_A4, NOTE_F4, 
  NOTE_E4, NOTE_D4, NOTE_AS4, NOTE_AS4,
  NOTE_A4, NOTE_F4, NOTE_G4,
  NOTE_F4
};

int durations[] = {
  4, 8, 
  4, 4, 4,
  2, 4, 8, 
  4, 4, 4,
  2, 4, 8,
  
  4, 4, 4, 
  4, 4, 4, 8,
  4, 4, 4,
  2
};


int real_hour;
int real_minute;

static const unsigned char u8g2_logo_97x51_bits[] U8X8_PROGMEM = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x80,0xC6,0x27,0x81,0x01,
0x14,0x00,0x00,0x00,0x80,0x4F,0xA4,0x67,0x00,0x22,0x00,0x00,0x00,0xC0,0x46,0x74,
0xA5,0x01,0x21,0x00,0x00,0x00,0x40,0xCF,0xA7,0xEF,0x83,0x7F,0x00,0x00,0x00,0x00,
0x46,0x24,0x83,0xC1,0x7F,0x00,0x00,0x00,0x80,0xDF,0xA7,0xA4,0x25,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x10,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
0x02,0x00,0x02,0x00,0x00,0x00,0x00,0x80,0x3F,0x81,0x3F,0x02,0x00,0x00,0x00,0x00,
0xE0,0xC0,0xE0,0x7F,0x04,0x00,0x00,0x00,0x00,0x70,0x80,0x73,0xC0,0x05,0x00,0x00,
0x00,0x00,0x30,0x00,0x1F,0x80,0x09,0x00,0x00,0x00,0x00,0x18,0x00,0x0E,0x00,0x0B,
0x00,0x00,0x00,0x00,0x08,0x0C,0x0C,0x00,0x16,0x00,0x00,0x00,0x00,0x0C,0x1E,0x04,
0x03,0x16,0x00,0x00,0x00,0x00,0x0C,0x3E,0x86,0x07,0x24,0x00,0x00,0x00,0xF8,0x0F,
0x3E,0x86,0x07,0x64,0x00,0x00,0x00,0xBE,0x0F,0x1E,0x86,0x07,0x44,0x0F,0x00,0x00,
0x07,0x0C,0x08,0x84,0x07,0xFC,0x0F,0x00,0x00,0x03,0x0C,0x00,0x06,0x00,0xE6,0x0F,
0x00,0x80,0x01,0x18,0x00,0x0E,0x00,0x86,0x0F,0x00,0x80,0x01,0x38,0x00,0x0F,0x00,
0x03,0x0E,0x00,0x80,0x01,0x70,0x80,0x1B,0x80,0x01,0x0C,0x00,0x80,0x01,0xE0,0xF3,
0x71,0xE0,0x00,0x78,0x00,0x80,0x01,0x80,0x7F,0xE0,0x7F,0x00,0xF8,0x01,0x80,0x01,
0x00,0x00,0x80,0x1F,0x00,0xF0,0x01,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0xF0,0x01,
0x00,0x01,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x03,
0x60,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x01,0x60,0x00,0x00,0x06,0x00,0x00,0x00,
0x00,0x01,0x60,0x00,0x00,0x0C,0x00,0x01,0x00,0x00,0x01,0x60,0x00,0x00,0x1C,0x80,
0x02,0x00,0x00,0x01,0xE0,0x00,0x00,0x38,0x40,0x04,0x00,0x80,0x03,0xE0,0x00,0x00,
0x70,0x20,0x08,0x00,0xC0,0x03,0xF0,0x01,0x00,0xC0,0x61,0x0C,0x00,0xF0,0x06,0xF0,
0x01,0x00,0x80,0x7F,0x3C,0x00,0x3E,0x1C,0xF0,0x00,0x00,0x00,0x82,0x63,0xE0,0x0F,
0x18,0x78,0x00,0x00,0x80,0xB1,0xDB,0xFF,0x01,0x00,0x1C,0x00,0x00,0xC0,0x80,0x83,
0x1F,0x00,0x00,0x0C,0x00,0x00,0x60,0x86,0x63,0x01,0x00,0x00,0x0E,0x00,0x00,0x20,
0x80,0x03,0x03,0x00,0x00,0x07,0x00,0x00,0x60,0x00,0x00,0x03,0x00,0x00,0x03,0x00,
0x00,0xE0,0x00,0x80,0x03,0x00,0x00,0x03,0x00,0x00,0xA0,0x19,0xCE,0x02,0x00,0x00,
0x02,0x00,0x00,0x30,0x03,0x60,0x02,0x00,0x00,0x1E,0x00,0x00,0x78,0xFE,0xBF,0xFF,
0x00,0x00,0x1E,0x00,0x00,0xC8,0x00,0x80,0xF1,0x03,0x00,0x1C,0x00,0x00,0x88,0x01,
0xC0,0x00,0x03,0x00,0x0C,0x00,0x00,0x98,0xFF,0xFF,0x00,0x00,0x00,0x0C,0x00,0x00,
0x90,0x20,0x80,0x01,0x00,0x00,0xF8,0x00,0x00,0xF0,0x21,0xC0,0x01,0x00,0x00,0xF0,
0x00,0x00,0x40,0x20,0x00,0x03,0x00,0x00,0x70,0x00,0x00,0x00,0x20,0x00,0x07,0x00,
0x00,0x60,0x00,0x00,0x00,0x20,0x00,0x1E,0x00,0x00,0xC0,0x00,0x00,0x00,0x20,0x00,
0x18,0x00,0x00,0x80,0x03,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,
0x60,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"C:\Users\pc\Desktop\生日快乐.bmp",0*/


 };

void alarm();
void setup() {
  Serial.begin(9600);

  //initialize the RTC
  if (! rtc.begin()) { // if failed then
    Serial.println("Couldn't find RTC");
    Serial.flush(); 
    abort();  // stop the procedure
  }
  pinMode(buzzer, OUTPUT);
  pinMode(button, INPUT);
  // initialize the u8g2
  u8g2.begin(); 
}

void loop() {

  // get time. For the first time you use the DS3231, you should set_time first, reference of the example of RCT_lib Library
  DateTime now = rtc.now();

  u8g2.setFont(u8g2_font_ncenB10_tr);  //  set the Font
  u8g2.setFontDirection(0);
  u8g2.firstPage(); 

  // first page/next page
  do { 
    u8g2.setCursor(20, 12); 
    u8g2.print("Current Time"); 
    u8g2.setCursor(30, 40);
    u8g2.print(now.year()); 
    u8g2.print("-");
    u8g2.print(now.month());
    u8g2.print("-");
    u8g2.print(now.day());

    u8g2.print(" ");

    u8g2.setCursor(35, 64);
    u8g2.print(now.hour());
    u8g2.print(":");
    u8g2.print(now.minute());
    u8g2.print(":");
    u8g2.print(now.second());
  } while ( u8g2.nextPage() );

  delay(20);
  real_hour = int(now.hour());
  real_minute = int(now.minute());
  if(real_hour == set_Hour && real_minute==set_Minute && alarm_lock==0)
  {
    alarm_lock = 1;
    alarm();
    
    //delay(60000);
  }
  if(real_minute == (set_Minute+1)){
    alarm_lock = 0;
  }

}
void alarm(){
  
  while(buttone_state == 1){
    //buttone_state = digitalRead(button);
    /*
    currentMillis = millis();
    if (currentMillis - previousMillis >= 1000) {
    // save the last time you blinked the LED
    previousMillis = currentMillis;

    // if the buzzer frequence is 1000, changing to 0;
    if (buzzer_state == 1000) {
      buzzer_state = buzzer_state-1000;
      tone(buzzer,buzzer_state,1000);
      //noTone(buzzer); //Stop sound
    } else {
      buzzer_state = buzzer_state+1000;
      tone(buzzer,buzzer_state);
    }

    // set the buzzer with the buzzer_state of the variable:
    //tone(buzzer,buzzer_state);
    }
    */
    u8g2.firstPage(); 
  // first page/next page
  do { 
      //u8g2.setCursor(20, 15); 
      //u8g2.print("GET UP!!!"); 
      u8g2.setFont(u8g2_font_ncenB14_tr);
    //u8g2.setCursor(30,0);
      u8g2.drawXBMP(30,0, 69, 64, u8g2_logo_97x51_bits);
  } while ( u8g2.nextPage() );

  delay(20);
    /*
    tone(buzzer, 1000); //Send 1KHz sound signal
    delay(1000);
    noTone(buzzer); //Stop sound
    delay(1000);
    */
    int size = sizeof(durations) / sizeof(int);

  for (int note = 0; note < size; note++) {
    //to calculate the note duration, take one second divided by the note type.
    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
    int duration = 1000 / durations[note];
    tone(buzzer, melody[note], duration);

    //to distinguish the notes, set a minimum time between them.
    //the note's duration + 30% seems to work well:
    int pauseBetweenNotes = duration * 1.30;
    delay(pauseBetweenNotes);
    
    //stop the tone playing:
    noTone(buzzer);
    buttone_state = digitalRead(button);
    if (buttone_state == 0) {
      break;
    }
  }
  }
  //Once the button is pressed, showing another kind of sound to remind the user.
  tone(12,3000,500);

}